<!DOCTYPE html>
<!--    
    This file is part of OpenNotebook-Web

    OpenNotebook-Web is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenNotebook-Web is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenNotebook-Web.  If not, see <http://www.gnu.org/licenses/>. 
-->
<html>
<head>
<!-- http://paletton.com/#uid=13u0u0kllllaFw0g0qFqFg0w0aF --> 

<meta name="viewport" content="width=624">
<title>Open Notebook</title>

<link rel="stylesheet" type="text/css" href="../build/mathquill.css">
<link rel="stylesheet" type="text/css" href="support/home.css">
<!-- testing -->
<script src="../expect.min.js"></script>

<!-- UI react-->
<script src="react/build/react.js"></script>
<script src="react/build/react-dom.js"></script>

<script src="../babel.min.js"></script>
<!-- input sanitiation --> 
<!-- script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.2/marked.min.js"></script -->

<!-- saving to local disk -->
<script type="text/javascript" src="../filesaver_js.js"></script>
<!-- reading ZIP files -->
<script type="text/javascript" src="../Stuk-jszip-82ceacc/dist/jszip.js"></script>

<!-- Only use this for MathQuill! --> 
<script type="text/javascript" src="support/jquery-1.7.2.js"></script>

<script type="text/javascript" src="../build/mathquill-basic.js"></script>
<!-- App state management -->
<script type="text/javascript" src="../redux.js"></script>
<script type="text/javascript" src="../lodash.min.js"></script>
<script type="text/babel">

// copied from here, didn't seem worth adding a dependency, I'm sure the JS people will cure me of that eventually...
// https://github.com/substack/deep-freeze/blob/master/index.js
function deepFreeze (o) {
  Object.freeze(o);

  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (o.hasOwnProperty(prop)
    && o[prop] !== null
    && (typeof o[prop] === "object" || typeof o[prop] === "function")
    && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  
  return o;
};

//Learning Redux

const UNTITLED_ASSINGMENT = 'Untitled Assignment';

// Application state properties
// TODO - use these as the actual keys in object literals in the reducer
// when I have ES6 and Babel

// Redux things
var type = 'type';

// Application modes
var APP_MODE = 'APP_MODE';
var EDIT_ASSIGNMENT = 'EDIT_ASSIGNMENT';
var GRADE_ASSIGNMENTS = 'GRADE_ASSIGNMENTS';

// Object model for teacher grading experience, see return value in the aggreateStudentWork() method
var STUDENT_FILE = 'STUDENT_FILE';
var ASSIGNMENT = 'ASSIGNMENT';
var UNIQUE_ANSWERS = 'UNIQUE_ANSWERS';
var AUTOMATICALLY_ASSIGNED_SCORE = 'AUTOMATICALLY_ASSIGNED_SCORE';
var PROBLEM_SCORE = 'PROBLEM_SCORE';
var SUCCESS_HIGHLIGHTS = 'SUCCESS_HIGHLIGHTS';

// answer key properties
var GRADE_STRATEGY = "GRADE_STRATEGY";
var ALL_ANSWERS_REQUIRED = "ALL_ANSWERS_REQUIRED";
var ONE_ANSWER_REQUIRED = "ONE_ANSWER_REQUIRED";
var SUBSET_OF_ANSWERS_REQUIRED = "SUBSET_OF_ANSWERS_REQUIRED";
var NUMBER_OF_MATCHING_ANSWERS_REQUIRED = "NUMBER_OF_MATCHING_ANSWERS_REQUIRED";
var POSSIBLE_POINTS = "POSSIBLE_POINTS";
var ANSWER_CLASSES = "ANSWER_CLASSES";
var ANSWERS = "ANSWERS";
var SCORE = "SCORE";

// teacher grade page model properties
var CORRECT = "CORRECT";
var PARTIALLY_CORRECT = "PARTIALLY_CORRECT";
var INCORRECT = "INCORRECT";
var SHOW_ALL = "SHOW_ALL";
var SHOW_NONE = "SHOW_NONE";
var STUDENT_WORK = "STUDENT_WORK";
var ANSWER = "ANSWER";

// teacher grading actions

// action properties
// PROBLEM_NUMBER, SOLUTION_CLASS_INDEX, SCORE, SOLUTION_INDEX
var GRADE_SINGLE_SOLUTION = "GRADE_SINGLE_SOLUTION";
// action properties
// PROBLEM_NUMBER, SOLUTION_CLASS_INDEX, SCORE 
var GRADE_CLASS_OF_SOLUTIONS = "GRADE_CLASS_OF_SOLUTIONS";
var SOLUTION_CLASS_INDEX = "SOLUTION_CLASS_INDEX";
var HIDE_BY_CORRECTNESS = "HIDE_BY_CORRECTNESS";
var HIDE_CLASS_OF_SOLUTIONS = "HIDE_CLASS_OF_SOLUTIONS";
var TOGGLE_GRADING_ANONYMOUSLY = "TOGGLE_GRADING_ANONYMOUSLY";

var SOLUTION_INDEX = "SOLUTION_INDEX";

// Assignment properties
var ASSIGNMENT_NAME = 'ASSIGNMENT_NAME';
var PROBLEMS = 'PROBLEMS';

// Problem properties
var PROBLEM_NUMBER = 'PROBLEM_NUMBER';
var STEPS = 'STEPS';
// to implement undo/redo and index for the last step
// to show is tracked and moved up and down
// when this is not at the end of the list and a new
// step is added it moves to the end of the list as
// the redo history in this case will be lost
var LAST_SHOWN_STEP = 'LAST_SHOWN_STEP';

// editing assignmnt mode actions
var SET_ASSIGNMENT_NAME = 'SET_ASSIGNMENT_NAME';
// used to swap out the entire content of the document, for opening
// a document from a file
var SET_ASSIGNMENT_CONTENT = 'SET_ASSIGNMENT_CONTENT';

// student assignment actions
var ADD_PROBLEM = 'ADD_PROBLEM';
// remove problem expects an "index" property 
// specifying which problem to remove
var REMOVE_PROBLEM = 'REMOVE_PROBLEM';
var CLONE_PROBLEM = 'CLONE_PROBLEM';

// this action expects:
// PROBLEM_INDEX - for which problem to change
// NEW_PROBLEM_NUMBER - string with problem number, not a numberic
//                    type because the problem might be 1.a, etc.
var PROBLEM_INDEX = 'PROBLEM_INDEX';
var NEW_PROBLEM_NUMBER = 'NEW_PROBLEM_NUMBER';
var SET_PROBLEM_NUMBER = 'SET_PROBLEM_NUMBER';

// key used to refer to one step in a series of student work
var STEP_KEY = 'STEP_KEY';
// key used to refer to data to place at a given step
// currently will just be a string with latex, but may change
// type if other metadata needs to be stored with each step
// such as a flag the student could set to indicate more than
// 1 final answer
var NEW_STEP_CONTENT = 'NEW_STEP_CONTENT';

// this action expects:
// PROBLEM_INDEX - for which problem to change
// STEP_KEY - index into the work steps for the given problem
// NEW_STEP_CONTENT - string for the new expression to write in this step
var EDIT_STEP = 'EDIT_STEP';
// TODO - decide if I want to add a feature to splice in
// a new step partway through a current problem
// this action expects an index for which problem to change
var NEW_STEP = 'NEW_STEP';
// this action expects an index for which problem to change
var UNDO_STEP = 'UNDO_STEP';
// this action expects an index for which problem to change
var REDO_STEP = 'REDO_STEP';

// open zip file full of student assignments for grading
function studentSubmissionsZip(evt) {

    var f = evt.target.files[0]; 

    if (f) {
        var r = new FileReader();
        r.onload = function(e) { 
            var content = e.target.result;

            var new_zip = new JSZip();
            // more files !
            new_zip.load(content);

            var allStudentWork = [];

            // you now have every files contained in the loaded zip
            for (var file in new_zip.files) { 
                // don't get properties from prototype
                if (new_zip.files.hasOwnProperty(file)) {
                    // extra directory added when zipping files on mac
                    // TODO - check for other things to filter out from zip
                    // files created on other platforms
                    if (file.indexOf("__MACOSX") > -1 || file.indexOf(".DS_Store") > -1) continue;
                    // filter out directories which are part of this list
                    if (new_zip.file(file) == null) continue; 
                    var fileContents = new_zip.file(file).asText();
                    // how is this behaviring differrntly than JSOn.parse()?!?!
                    var assignmentData = $.parseJSON(fileContents);
                    allStudentWork.push({STUDENT_FILE : file, ASSIGNMENT : assignmentData});
                }
            }
            // TODO - add back answer key
            var aggregatedWork = aggregateStudentWork(allStudentWork);
        }
        r.readAsArrayBuffer(f);
    } else { 
        alert("Failed to load file");
    }
}

// returns score out of total possible points that are specified in the answer key
function gradeSingleProblem(problem, answerKey) {
    var automaticallyAssignedGrade;
    var problemKey = answerKey[problem[PROBLEM_NUMBER]];
    $.each(problemKey[ANSWER_CLASSES], function(answerClassIndex, answerClass) {
        var exitEarly = false;
        if (answerClass[GRADE_STRATEGY] === ONE_ANSWER_REQUIRED) {
            $.each(answerClass[ANSWERS], function(answerIndex, answer) {
            var studentAnswer = _.last(problem[STEPS]);
            // TODO - better expression comparison
            // var expr1 = KAS.parse(answer).expr;
            // var expr2 = KAS.parse(studentAnswer).expr;
            // if (KAS.compare(expr1, expr2).equal) {
            if (answer == studentAnswer) {
                // TODO - good rounding
                automaticallyAssignedGrade = answerKey[problem[PROBLEM_NUMBER]][POSSIBLE_POINTS] * answerClass[SCORE];
                exitEarly = true;
                return false; // early terminate loops
            }
            });
        } else {
        alert("This grading strategy has not been implemented - " + answerClass[GRADE_STRATEGY]);
        }
        if (exitEarly) return false;
    });
    return automaticallyAssignedGrade;
}

//      [ { "PROBLEM_NUMBER" : "1", POSSIBLE_POINTS : 3, "ANSWER_CLASSES" : [ { SCORE : 1, ANSWERS : ["x=5", "5=x"]}, { "SCORE" : 0.5, ANSWERS : ["x=-5","-5=x"] ],
//          "GRADE_STRATEGY" : "ALL_ANSWERS_REQUIRED" | "ONE_ANSWER_REQUIRED" | "SUBSET_OF_ANSWERS_REQUIRED", "NUMBER_OF_MATCHING_ANSWERS_REQUIRED" : 2 } ]
function testGradeProblem() {
    var answerKey = { "1" : { POSSIBLE_POINTS : 3,
                        ANSWER_CLASSES : [  { SCORE : 1, ANSWERS : ["x=5", "5=x"], GRADE_STRATEGY : ONE_ANSWER_REQUIRED },
                                            { SCORE : 0.5, ANSWERS : ["x=-5", "-5=x"], GRADE_STRATEGY : ONE_ANSWER_REQUIRED }] } };
    var studentAnswer1 = { PROBLEM_NUMBER : 1, STEPS : [ "2x=10", "x=5"]};
    var studentAnswer2 = { PROBLEM_NUMBER : 1, STEPS : [ "2x=10", "x=-5"]};
    expect(gradeSingleProblem(studentAnswer1, answerKey)).toEqual(3);
    expect(gradeSingleProblem(studentAnswer2, answerKey)).toEqual(1.5);
}

function testAggregateStudentWork() {
    var allStudentWork = [ {STUDENT_FILE : "jake r.", ASSIGNMENT: [{PROBLEM_NUMBER : 1, LAST_SHOWN_STEP : 1, STEPS : ["5x=10", "x=2"]}]},
                           {STUDENT_FILE : "jon m.", ASSIGNMENT: [{PROBLEM_NUMBER : 1, LAST_SHOWN_STEP : 1, STEPS : ["5x=10", "x=-2"]}]} ];
    var answerKey = { "1" : { 
            POSSIBLE_POINTS : 3, 
            ANSWER_CLASSES : [ { SCORE : 1, ANSWERS : ["x=2", "2=x"], GRADE_STRATEGY : ONE_ANSWER_REQUIRED}, 
                                { SCORE : 0.5, ANSWERS : ["x=-2","-2=x"], GRADE_STRATEGY : ONE_ANSWER_REQUIRED } ],
            } };
    var expectedOutput = {
        CURRENT_FILTERS : { SIMILAR_ASSIGNMENT_GROUP_INDEX : null, CORRECTNESS : [ CORRECT, PARTIALLY_CORRECT, INCORRECT], ANONYMOUS : true },
        SIMILAR_ASSIGNMENT_SETS : [ ],
        STUDENT_WORK : { "1" : {
            POSSIBLE_POINTS : 3,
            UNIQUE_ANSWERS : [ 
                { ANSWER : "x=2", FILTER : SHOW_ALL, STUDENT_WORK : [ {STUDENT_FILE : "jake r.", AUTOMATICALLY_ASSIGNED_SCORE : 3, SCORE : 3, FEEDBACK : "",
                    STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=2"} ] } ] }, 
                    { ANSWER : "x=-2", FILTER : SHOW_ALL, STUDENT_WORK : [ {STUDENT_FILE : "jon m.", AUTOMATICALLY_ASSIGNED_SCORE : 1.5,  SCORE : 1.5,FEEDBACK : "",
                    STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=-2"} ] } ] } ]
        } }
    };
    expect(aggregateStudentWork(allStudentWork, answerKey)).toEqual(expectedOutput);
}

function testAggregateStudentWorkNoAnswerKey() {
    var allStudentWork = [ {STUDENT_FILE : "jake r.", ASSIGNMENT: [{PROBLEM_NUMBER : 1, LAST_SHOWN_STEP : 1, STEPS : ["5x=10", "x=2"]}]},
                           {STUDENT_FILE : "jon m.", ASSIGNMENT: [{PROBLEM_NUMBER : 1, LAST_SHOWN_STEP : 1, STEPS : ["5x=10", "x=-2"]}]} ];
    var expectedOutput = {
        CURRENT_FILTERS : { SIMILAR_ASSIGNMENT_GROUP_INDEX : null, CORRECTNESS : [ CORRECT, PARTIALLY_CORRECT, INCORRECT], ANONYMOUS : true },
        SIMILAR_ASSIGNMENT_SETS : [ ],
        STUDENT_WORK : { "1" : {
            POSSIBLE_POINTS : 6,
            UNIQUE_ANSWERS : [ 
                { ANSWER : "x=2", FILTER : SHOW_ALL, STUDENT_WORK : [ {STUDENT_FILE : "jake r.", AUTOMATICALLY_ASSIGNED_SCORE : 0, SCORE : 0, FEEDBACK : "",
                    STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=2"} ] } ] }, 
                { ANSWER : "x=-2", FILTER : SHOW_ALL, STUDENT_WORK : [ {STUDENT_FILE : "jon m.", AUTOMATICALLY_ASSIGNED_SCORE : 0, SCORE : 0, FEEDBACK : "",
                    STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=-2"} ] } ] } ]
        } }
    };
    expect(aggregateStudentWork(allStudentWork)).toEqual(expectedOutput);
}

// Transforms a list of student assignments into a structure where all work for one problem
// is stored together, separated by different final answers reached by groups of students.
//
// In the answer key, scores on individual answers are given as a float value from [0,1).
// The grading strategy for individual problems (how to handle partial credit, fractional points
// and allowing users to scale some problems to be worth more points, is still being decided).
// Can't just use floating point for fractional points because users will expecting them to add up
// cleanly. Even if I decide on some fractional system, floating point partial credit scores would
// be safe enough to import with rounding. The again might just be over-thinking it and floats even
// after aggregation would be fine for "snapping" to common fractional values, just need to store
// all raw input so it can be shown back to users as what they entered.
//
// Params:
// allStudentWork:
//      [ {STUDENT_FILE : "jake r.", ASSIGNMENT: [{PROBLEM_NUMBER : 1, "STEPS" : }]]
// answerKey: - list of problem numbers with answers, given as a map with the problem numbers as keys
//              non-numeric keys are considered valid to allow 1.a, iii, 5.11, etc./
//              NUMBER_OF_MATCHING_ANSWERS_REQUIRED is only valid to set if SUBSET_OF_ANSWERS_REQUIRED is specified.
//              Each answer class has its own GRADE_STRATEGY because for a question with multiple answers, the partial
//              credit options will likely be defined as SUBSET_OF_ANSWERS_REQUIRED
//      { "1" : { POSSIBLE_POINTS : 3, "ANSWER_CLASSES" : [
//                { SCORE : 1, ANSWERS : ["x=5", "5=x"], "GRADE_STRATEGY" : "ALL_ANSWERS_REQUIRED" },
//                { "SCORE" : 0.5, ANSWERS : ["x=-5","-5=x"] ],
//                      "GRADE_STRATEGY" : "ALL_ANSWERS_REQUIRED" | "ONE_ANSWER_REQUIRED" | 
//                      "SUBSET_OF_ANSWERS_REQUIRED", "NUMBER_OF_MATCHING_ANSWERS_REQUIRED" : 2 } ]
//
// Returns:
// CURRENT_FILTERS : { SIMILAR_ASSIGNMENT_GROUP_INDEX : 1, CORRECTNESS : [ "INCORRECT", "PARTIALLY_CORRECT", "INCORRECT"], ANONYMOUS : true/false }
// SIMILAR_ASSIGNMENT_SETS : [ [ "jason", "emma", "matt"], ["jim", "tim"] ],
// STUDENT_WORK : { "1.a" : {
//      "POSSIBLE_POINTS : 3,
//      "UNIQUE_ANSWERS" : [ { ANSWER : "x=7", FILTER : "SHOW_ALL"/"SHOW_NONE", STUDENT_WORK : [ {STUDENT_FILE : "jason", AUTOMATICALLY_ASSIGNED_SCORE : 3, 
//                             STEPS : [ { CONTENT : "2x=14"},{ CONTENT : "x=7", HIGHLIGHT : SUCCESS ]} ] } } ]}
function aggregateStudentWork(allStudentWork, answerKey = {}) {
    var aggregatedWork = {};
    // used to simplify filling in a flag for missing work if a student does not do a problem
    // structure: { "1.1" : { "jason" :true, "taylor" : true }
    var studentWorkFound = {};
    console.log(answerKey);
    allStudentWork.forEach(function(assignInfo, index, array) {
        assignInfo[ASSIGNMENT].forEach(function(problem, index, array) {
            console.log(problem);
            var studentAnswer = problem[STEPS][problem[LAST_SHOWN_STEP] ];
            var automaticallyAssignedGrade = 0;

            if (!$.isEmptyObject(answerKey)) {
                // this problem did not appear in the answer key
                if (!answerKey[problem[PROBLEM_NUMBER]]) {
                    automaticallyAssignedGrade = 0;
                } else {
                    automaticallyAssignedGrade = gradeSingleProblem(problem, answerKey);
                }
            }

            // write into the abreviated list of problems completed, used below to fill in placeholder for
            // completely absent work
            var allStudentsWhoDidThisProblem = studentWorkFound[problem[PROBLEM_NUMBER]];
            allStudentsWhoDidThisProblem = (typeof allStudentsWhoDidThisProblem != 'undefined') ? allStudentsWhoDidThisProblem : {};
            allStudentsWhoDidThisProblem[assignInfo[STUDENT_FILE]] = true;
            studentWorkFound[problem[PROBLEM_NUMBER]] = allStudentsWhoDidThisProblem;
            
            var problemSummary = aggregatedWork[problem[PROBLEM_NUMBER]];
            problemSummary = (typeof problemSummary != 'undefined') ? problemSummary : {};

            var uniqueAnswers = problemSummary[UNIQUE_ANSWERS];
            uniqueAnswers = ( typeof uniqueAnswers != 'undefined') ? uniqueAnswers : [];
            
            // see notes for comment about how to organize problems once final answers are compared in
            // a fuzzy fashion
            var workList;
            var indexInUniqueAnswersList;
            uniqueAnswers.forEach(function(aggregatedWorkForOneAnswer, index, arr) {
                if (aggregatedWorkForOneAnswer[ANSWER] === studentAnswer) {
                    workList = aggregatedWorkForOneAnswer;
                    indexInUniqueAnswersList = index;
                    return false;
                }
            });
            if (typeof workList === 'undefined' || !(workList instanceof Object) ) {
                workList = { ANSWER : studentAnswer, FILTER : SHOW_ALL, STUDENT_WORK : []};
                indexInUniqueAnswersList = uniqueAnswers.length;
            }
            workList[STUDENT_WORK].push(
                { STUDENT_FILE : assignInfo[STUDENT_FILE], 
                  AUTOMATICALLY_ASSIGNED_SCORE : automaticallyAssignedGrade,
                  SCORE : automaticallyAssignedGrade,
                  FEEDBACK : '',
                  STEPS : wrapSteps(problem[STEPS])}
            );
            uniqueAnswers[indexInUniqueAnswersList] = workList;
            problemSummary[UNIQUE_ANSWERS] = uniqueAnswers;
            // this is currently redundant, but the next step to order all of the problems based
            // on which ones most students go wrong with rewrite the keys to numeric ones
            if (!$.isEmptyObject(answerKey)) {
                problemSummary[POSSIBLE_POINTS] = answerKey[problem[PROBLEM_NUMBER]][POSSIBLE_POINTS];
            } else {
                problemSummary[POSSIBLE_POINTS] = 6;
             }
            // this is necessary because this might be the first time this problem number was seen so we just created the list
            // if this wasn't the case, this wouldn't be necessary because objects including arrays are always passed by reference
            aggregatedWork[problem[PROBLEM_NUMBER]] = problemSummary;
        });
    });
    /*
    // add blank answers for any students missing problems
    $.each(allStudentWork, function(index, assignInfo) {
        $.each(studentWorkFound, function(problemNumber, studentsFound) {
            if (!studentsFound[assignInfo.filename]) {
                var missingWork = aggregatedWork[problemNumber]['uniqueAnswers']['unanswered'];
                missingWork = (typeof missingWork != 'undefined') ? missingWork : [];
                missingWork.push(
                        {studentFile : assignInfo.filename, autoGradeStatus: 'incorrect', steps : ['unanswered']});
                aggregatedWork[problemNumber]['uniqueAnswers']['unanswered'] = missingWork;
            }
        });
    });
    */
    console.log(aggregatedWork);

    return { CURRENT_FILTERS : { SIMILAR_ASSIGNMENT_GROUP_INDEX : null, CORRECTNESS : [ CORRECT, PARTIALLY_CORRECT, INCORRECT], ANONYMOUS : true },
    SIMILAR_ASSIGNMENT_SETS : [ ], STUDENT_WORK : aggregatedWork }
}

// currently in the student model, the steps associated with a problem
// are a simple array of strings with Latex in them. In the teacher
// gradng model, each step is wrapped in an object to allow for storing
// metadata with each step. Current usage is to show a highlight of an
// error or success identified by the teacher on that step.
function wrapSteps(studentSteps) {
    var wrappedSteps = [];
    studentSteps.forEach(function(step, index, arr) {
        wrappedSteps.push({CONTENT : step});
    });
    return wrappedSteps;
}

function saveAssignment() {
    var blob = new Blob([JSON.stringify({ PROBLEMS : store.getState()[PROBLEMS]})], {type: "text/plain;charset=utf-8"});
    saveAs(blob, store.getState()[ASSIGNMENT_NAME] + '.math'); 
}

// read a file from the local disk, pass an onChange event from a "file" input type
// http://www.htmlgoodies.com/beyond/javascript/read-text-files-using-the-javascript-filereader.html
function readSingleFile(evt) {
    //Retrieve the first (and only!) File from the FileList object
    var f = evt.target.files[0]; 

    if (f) {
        var r = new FileReader();
        r.onload = function(e) { 
            var contents = e.target.result;
            openAssignment(contents, f.name);  
        }
        r.readAsText(f);
    } else { 
        alert("Failed to load file");
    }
}

function openAssignment(serializedDoc, filename) {
    if (!window.confirm("Discard your current work and open the selected document?")) { 
        return; 
    }
    var newDoc = JSON.parse(serializedDoc);
    // compatibility for old files, need to convert the old proerty names as
    // well as add the LAST_SHOWN_STEP
    var newDoc = convertToCurrentFormat(newDoc);
    store.dispatch({type : SET_ASSIGNMENT_CONTENT, PROBLEMS : newDoc[PROBLEMS]});
    store.dispatch({type : SET_ASSIGNMENT_NAME, ASSIGNMENT_NAME : removeExtension(filename)});
}

function removeExtension(filename) {
    // remove preceding directory (for when filename comes out of the ZIP directory)
    filename = filename.replace(/[^\/]*\//, "");
    // actually remove extension
    filename = filename.replace(/\.[^/.]+$/, "");
    return filename;
}

function convertToCurrentFormat(possiblyOldDoc) {
    console.log(possiblyOldDoc);
    if (!possiblyOldDoc.hasOwnProperty('problems')) {
        console.log('new doc found');
        return possiblyOldDoc;
    }

    possiblyOldDoc.problems.forEach(function (problem) {
        if (problem.problemNumber !== undefined) {
            problem[STEPS] = problem.steps;
            problem[LAST_SHOWN_STEP] = newSteps.length - 1;
            problem[PROBLEM_NUMBER] = problem.problemNumber;
            delete problem.steps;
            delete problem.problemNumber;
        }
    });
    possiblyOldDoc[PROBLEMS] = possiblyOldDoc.problems;
    return possiblyOldDoc;
}

// reducer for an individual problem
function problem(problem, action) {
    if (problem === undefined) {
        return { PROBLEM_NUMBER : "", STEPS : [""], LAST_SHOWN_STEP : 0}
    } else if (action.type === SET_PROBLEM_NUMBER) {
        var newNamedProb = _.clone(problem)
        newNamedProb[PROBLEM_NUMBER] = action[NEW_PROBLEM_NUMBER];
        return newNamedProb;
    } else if (action.type === EDIT_STEP) {
        // TODO - I should avoid using cloneDeep, I think it migh be okay here though
        var editedProb = _.cloneDeep(problem)
        editedProb.STEPS[action.STEP_KEY] = action.NEW_STEP_CONTENT;
        return editedProb;
    } else if (action.type === NEW_STEP) {
        var editedProb = _.cloneDeep(problem);
        var oldLastStep = editedProb.STEPS[problem.LAST_SHOWN_STEP];
        editedProb[STEPS] = editedProb[STEPS].slice(0, problem.LAST_SHOWN_STEP + 1);
        editedProb[STEPS].push(oldLastStep);
        editedProb[LAST_SHOWN_STEP]++;
        return editedProb;
    } else if (action.type === UNDO_STEP) {
        if (problem[LAST_SHOWN_STEP] == 0) return problem;
        else {
            var editedProb = _.cloneDeep(problem);
            editedProb[LAST_SHOWN_STEP]--;
            return editedProb;
        }
    } else if (action.type === REDO_STEP) {
        if (problem[LAST_SHOWN_STEP] == problem[STEPS].length - 1) return problem;
        else {
            var editedProb = _.cloneDeep(problem);
            editedProb[LAST_SHOWN_STEP]++;
            return editedProb;
        }
    } else {
        return problem;
    }
}

// reducer for the list of problems in an assignment
function problems(probList, action) {
    if (probList === undefined) {
        return [ problem(undefined, action) ];
    }

    if (action.type === ADD_PROBLEM) {
        return _.clone(probList).concat(problem(undefined, action));
    } else if (action.type === REMOVE_PROBLEM) {
        return [
            ...probList.slice(0, action.PROBLEM_INDEX),
            ...probList.slice(action.PROBLEM_INDEX + 1)
        ];
    } else if (action.type === CLONE_PROBLEM) {
        var newProb = _.cloneDeep(probList[action.PROBLEM_INDEX]);
        newProb[PROBLEM_NUMBER] += ' - copy'; 
        return [
            ...probList.slice(0, action.PROBLEM_INDEX + 1),
            newProb,
            ...probList.slice(action.PROBLEM_INDEX + 1)
        ];
    } else if (action.type === SET_PROBLEM_NUMBER ||
               action.type === EDIT_STEP ||
               action.type === UNDO_STEP ||
               action.type === REDO_STEP ||
               action.type === NEW_STEP) {
        return [ 
            ...probList.slice(0, action.PROBLEM_INDEX),
            problem(probList[action.PROBLEM_INDEX], action),
            ...probList.slice(action.PROBLEM_INDEX + 1)
        ];
        return ret;
    } else {
        return probList;
    }
}

// reducer for an overall assignment
function assignment(state, action) {
    console.log(action);
    if (state === undefined) {
        /*
        return {
            APP_MODE : EDIT_ASSIGNMENT,
            ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
            PROBLEMS : problems(undefined, action)
            };
        */
        return {
            APP_MODE : GRADE_ASSIGNMENTS,
            CURRENT_FILTERS : { SIMILAR_ASSIGNMENT_GROUP_INDEX : null, CORRECTNESS : [ CORRECT, PARTIALLY_CORRECT, INCORRECT], ANONYMOUS : true },
            SIMILAR_ASSIGNMENT_SETS : [ ],
            STUDENT_WORK : { "1" : {
                POSSIBLE_POINTS : 6,
                UNIQUE_ANSWERS : [ 
                { ANSWER : "x=2", FILTER : SHOW_ALL, STUDENT_WORK : [ 
                    { STUDENT_FILE : "jake r.", AUTOMATICALLY_ASSIGNED_SCORE : 0, 
                      SCORE : 0, FEEDBACK : "",
                      STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=2"} ] },
                    { STUDENT_FILE : "alica m.", AUTOMATICALLY_ASSIGNED_SCORE : 0,
                      SCORE : 0, FEEDBACK : "",
                      STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "5x=10"},{ CONTENT : "x=2"} ] }] }, 
                { ANSWER : "x=-2", FILTER : SHOW_ALL, STUDENT_WORK : [
                    { STUDENT_FILE : "jon m.", AUTOMATICALLY_ASSIGNED_SCORE : 0,
                      SCORE : 0, FEEDBACK : "",
                      STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=-2"} ] } ] } ]
            } }
        };
    } else if (action.type === SET_ASSIGNMENT_NAME) {
        state = _.cloneDeep(state);
        state.ASSIGNMENT_NAME = action.ASSIGNMENT_NAME;
        return state;
    } else if (action.type === SET_ASSIGNMENT_CONTENT) {
        state = _.cloneDeep(state);
        state.PROBLEMS = action.PROBLEMS;
        console.log('new state');
        console.log(state);
        return state;
    } else {
        var new_state = _.clone(state);
        new_state[PROBLEMS] = problems(new_state[PROBLEMS], action); 
        return new_state;
    }
}

// CURRENT_FILTERS : { SIMILAR_ASSIGNMENT_GROUP_INDEX : 1, CORRECTNESS : [ "INCORRECT", "PARTIALLY_CORRECT", "INCORRECT"], ANONYMOUS : true/false }
// SIMILAR_ASSIGNMENT_SETS : [ [ "jason", "emma", "matt"], ["jim", "tim"] ],
// STUDENT_WORK : { "1.a" : {
//      "POSSIBLE_POINTS : 3,
//      "UNIQUE_ANSWERS" : [ { ANSWER : "x=7", FILTER : "SHOW_ALL"/"SHOW_NONE", STUDENT_WORK : [ {STUDENT_FILE : "jason", AUTOMATICALLY_ASSIGNED_SCORE : 3, 
//                             STEPS : [ { CONTENT : "2x=14"},{ CONTENT : "x=7", HIGHLIGHT : SUCCESS ]} ] } } ]}
// reducer for teacher grading page
function grading(state, action) {
    if (state === undefined) {
        alert("Defualt state has not been defined for teacher grading experience");
    } else if (action.type === GRADE_CLASS_OF_SOLUTIONS) {
        var newState = state; 
        var allWorkForProblem = newState[STUDENT_WORK][action[PROBLEM_NUMBER]];
        var workInGivenSolutionClass = allWorkForProblem[UNIQUE_ANSWERS][action[SOLUTION_CLASS_INDEX]][STUDENT_WORK];
        workInGivenSolutionClass.forEach(function(singleStudentsWork, index, arr) {
            newState = setDeepImmutable(
                newState, 
                [ STUDENT_WORK, action[PROBLEM_NUMBER], UNIQUE_ANSWERS,
                    action[SOLUTION_CLASS_INDEX], STUDENT_WORK, index, SCORE],
                    action[SCORE]);
        });
        return newState;
    } else if (action.type === GRADE_SINGLE_SOLUTION) {
        return setDeepImmutable(state, 
                                [ STUDENT_WORK, action[PROBLEM_NUMBER], UNIQUE_ANSWERS, 
                                  action[SOLUTION_CLASS_INDEX], STUDENT_WORK, action[SOLUTION_INDEX], SCORE], action[SCORE]);
    }
}

// trying to create utility function for updating part of a nested structure
// while respecting Redux immutable model, this is a basic reducer to test the function
// input : { username : "asdf",
//           events : [ { name : "pirate party", date : "aug 30"}, { name : "dance party", date : "jan 1" } ]
//         }
// action : { type : "updateDate", eventIndex : 0, newDate : "jan 10" }
function userEventReducer(state, action) {
    if (action.type === 'updateDate') {
        return setDeepImmutable( state, ['events', action.eventIndex, 'date'], action.newDate);
        /*
        var newRoot = _.clone(state);
        newRoot.events = _.clone(state.events);
        newRoot.events[action.eventIndex] = _.clone(state.events[action.eventIndex]);
        newRoot.events[action.eventIndex].date = action.newDate;
        return newRoot;
        */
        /*
        return {
            ...state,
            events : [
                ...state.events.slice(0, action.eventIndex),
                { ...state.events[action.eventIndex],
                    date : action.newDate
                },
                ...state.events.slice(action.eventIndex + 1),
            ]
        };
        */
        //var newState = _.cloneDeep(state);
        //newState.events[action.eventIndex].date = action.newDate;
        //return newState;
    }
}

function setDeepImmutable(orig, pathDown, newVal) {
    // shallow copy
    var newRoot = _.clone(orig);
    var currentLevel = newRoot;
    pathDown.forEach(function(pathSegment, index, array) {
        var valToInsert;
        if (index == array.length - 1 ) {
            valToInsert = newVal;
        } else {
            valToInsert = _.clone(currentLevel[pathSegment]);
        }
        if (typeof(pathSegment) === 'string') {
            currentLevel[pathSegment] = valToInsert;
            currentLevel = currentLevel[pathSegment];
            return true;
        } else if (typeof(pathSegment) === 'number') {
            currentLevel[pathSegment] = valToInsert;
            currentLevel = currentLevel[pathSegment];
            return true;
        } else {
            console.log("Unsupported type given for nested structure traversal, only strings and numbers can be given");
        }
    });
    return newRoot;
}

function testNestedUpdate(state, action) {
    var initialState = { username : "asdf", events : [ { name : "priate party", date : "aug 30"} ] };
    var action = { type : "updateDate", eventIndex : 0, newDate : "jan 10" };
    var expectedOut = { username : "asdf", events : [ { name : "priate party", date : "jan 10"} ] };
    deepFreeze(initialState);
    expect(userEventReducer(initialState, action)).toEqual(expectedOut);
}

var createStore = Redux.createStore;
var store = createStore(assignment);

function render() {
    ReactDOM.render(
        <OpenNotebook value={store.getState()} />,
        document.getElementById('root')
    );
}

MathQuill.interfaceVersion(1);
var PT = React.PropTypes;

// A WYSIWYG math input that calls `onChange(LaTeX-string)`
var MathInput = React.createClass({
    propTypes: {
        value: PT.string,
        convertDotToTimes: PT.bool,
        buttonsVisible: PT.oneOf(['always', 'never', 'focused']),
        labelText: React.PropTypes.string,
        onFocus: PT.func,
        onBlur: PT.func,
    },

    render: function() {
        // mathquill usually adds these itself but react removes them when
        // updating the component.
        var className = "perseus-math-input mq-editable-field mq-math-mode";

        if (this.props.className) {
            className = className + " " + this.props.className;
        }

        var buttons = null;
        /*
        if (this._shouldShowButtons()) {
            buttons = <TexButtons
                sets={this.props.buttonSets}
                className="math-input-buttons absolute"
                convertDotToTimes={this.props.convertDotToTimes}
                onInsert={this.insert} />;
        }
        */

        return <div>
            <div style={{display: 'inline-block'}}>
                <span className={className}
                      ref="mathinput"
                      aria-label={this.props.labelText}
                      onFocus={this.handleFocus}
                      onBlur={this.handleBlur} />
            </div>
        </div>;
    },

    // handlers:
    // keep track of two related bits of state:
    // * this.state.focused - whether the buttons are currently shown
    // * this.mouseDown - whether a mouse click is active that started in the
    //   buttons div

    handleFocus: function() {
        console.log("focused");
        this.setState({ focused: true });
        // TODO(joel) fix properly - we should probably allow onFocus handlers
        // to this property, but we need to work correctly with them.
        // if (this.props.onFocus) {
        //     this.props.onFocus();
        // }
    },

    handleMouseDown: function(event) {
        var focused = ReactDOM.findDOMNode(this).contains(event.target);
        this.mouseDown = focused;
        if (!focused) {
            this.setState({ focused: false });
        }
    },

    handleMouseUp: function() {
        // this mouse click started in the buttons div so we should focus the
        // input
        if (this.mouseDown) {
            this.focus();
        }
        this.mouseDown = false;
    },

    handleBlur: function() {
        if (!this.mouseDown) {
            this.setState({ focused: false });
        }
    },

    _shouldShowButtons: function() {
        if (this.props.buttonsVisible === 'always') {
            return true;
        } else if (this.props.buttonsVisible === 'never') {
            return false;
        } else {
            return this.state.focused;
        }
    },

    getDefaultProps: function() {
        return {
            value: "",
            convertDotToTimes: false,
            buttonsVisible: 'focused'
        };
    },

    getInitialState: function() {
        return { focused: false };
    },

    insert: function(value) {
        var input = this.mathField();
        if (_(value).isFunction()) {
            value(input);
        } else if (value[0] === '\\') {
            input.cmd(value).focus();
        } else {
            input.write(value).focus();
        }
        input.focus();
    },

    mathField: function(options) {
        // MathQuill.MathField takes a DOM node, MathQuill-ifies it if it's
        // seeing that node for the first time, then returns the associated
        // MathQuill object for that node. It is stable - will always return
        // the same object when called on the same DOM node.
        return MathQuill.MathField(ReactDOM.findDOMNode(this.refs.mathinput), options);
    },

    componentWillUnmount: function() {
        window.removeEventListener("mousedown", this.handleMouseDown);
        window.removeEventListener("mouseup", this.handleMouseUp);
    },

    componentDidMount: function() {
        window.addEventListener("mousedown", this.handleMouseDown);
        window.addEventListener("mouseup", this.handleMouseUp);

        // These options can currently only be set globally. (Hopefully this
        // will change at some point.) They appear safe to set multiple times.

        // LaTeX commands that, when typed, are immediately replaced by the
        // appropriate symbol. This does not include ln, log, or any of the
        // trig functions; those are always interpreted as commands.
        //MathQuill.addAutoCommands("pi theta phi sqrt nthroot");

        // Pop the cursor out of super/subscripts on arithmetic operators or
        // (in)equalities.
        // MathQuill.addCharsThatBreakOutOfSupSub("+-*/=<>≠≤≥");

        // Prevent excessive super/subscripts or fractions from being created
        // without operands, e.g. when somebody holds down a key
        //MathQuill.disableCharsWithoutOperand("^_/");

        var initialized = false;
        console.log(this)

        // Initialize MathQuill.MathField instance
        this.mathField({
            // The name of this option is somewhat misleading, as tabbing in
            // MathQuill breaks you out of a nested context (fraction/script)
            // if you're in one, but moves focus to the next input if you're
            // not. Spaces (with this option enabled) are just ignored in the
            // latter case.
            //
            // TODO(alex): In order to allow inputting mixed numbers, we will
            // have to accept spaces in certain cases. The desired behavior is
            // still to escape nested contexts if currently in one, but to
            // insert a space if not (we don't expect mixed numbers in nested
            // contexts). We should also limit to one consecutive space.
            spaceBehavesLikeTab: true,

            // for intuitive navigation of fractions
            leftRightIntoCmdGoes: 'up',
            autoCommands: 'pi theta sqrt sum',
            autoSubscriptNumerals: true,
            charsThatBreakOutOfSupSub: '+-*/=<>≠≤≥',

            handlers: {
                edited: (mathField) => {
                    // This handler is guaranteed to be called on change, but
                    // unlike React it sometimes generates false positives.
                    // One of these is on initialization (with an empty string
                    // value), so we have to guard against that below.
                    console.log("EDITED!");
                    var value = mathField.latex();

                    // Provide a MathQuill-compatible way to generate the
                    // not-equals sign without pasting unicode or typing TeX
                    value = value.replace(/<>/g, "\\ne");

                    // Use the specified symbol to represent multiplication
                    // TODO(alex): Add an option to disallow variables, in
                    // which case 'x' should get converted to '\\times'
                    if (this.props.convertDotToTimes) {
                        value = value.replace(/\\cdot/g, "\\times");

                        // Preserve cursor position in the common case:
                        // typing '*' to insert a multiplication sign.
                        // We do this by modifying internal MathQuill state
                        // directly, instead of waiting for `.latex()` to be
                        // called in `componentDidUpdate()`.
                        var left = mathField.controller.cursor[MathQuill.L];
                        if (left && left.ctrlSeq === '\\cdot ') {
                            mathField.controller.backspace();
                            mathField.cmd('\\times');
                        }
                    } else {
                        value = value.replace(/\\times/g, "\\cdot");
                    }

                    if (initialized && this.props.value !== value) {
                        //this.props.onChange(value);
                        console.log("SETTING NEW VALUE");
                        store.dispatch({ type : EDIT_STEP, PROBLEM_INDEX : this.props.problemIndex, 
                                         STEP_KEY : this.props.stepIndex, NEW_STEP_CONTENT : value});
                    }
                },
                enter: () => {
                    // This handler is called when the user presses the enter
                    // key. Since this isn't an actual <input> element, we have
                    // to manually trigger the usually automatic form submit.

                    console.log("enter pressed");
                    // Using enter for go to next step
                    store.dispatch({ type : NEW_STEP, PROBLEM_INDEX : this.props.problemIndex});

                    //$(ReactDOM.findDOMNode(this.refs.mathinput)).submit();
                },
                upOutOf: (mathField) => {
                    // This handler is called when the user presses the up
                    // arrow key, but there is nowhere in the expression to go
                    // up to (no numerator or exponent). For ease of use,
                    // interpret this as an attempt to create an exponent.
                    console.log("Up");
                    mathField.typedText("^");
                }
            }
        });

        // Ideally, we would be able to pass an initial value directly into
        // the constructor above
        this.mathField().latex(this.props.value);
        this.mathField().focus();
        console.log("mathfield init");
        initialized = true;
    },

    componentDidUpdate: function() {
        console.log("mathfield component did update");
        if (!_.isEqual(this.mathField().latex(), this.props.value)) {
            console.log("mathfield component did update 2: " + this.props.value);
            console.log(this.props);
            this.mathField().latex(this.props.value);
        }
    },

    focus: function() {
        this.mathField().focus();
        this.setState({ focused: true });
    },

    blur: function() {
        this.mathField().blur();
        this.setState({ focused: false });
    }
});


var Problem = React.createClass({

    handleStepChange: function(event) {
      this.setState({value: event.target.value});
    },
    render: function() {
        var problemIndex = this.props.id;
        var lastShownStep = this.props.value[LAST_SHOWN_STEP];
        return (
            <div className="problem-container" style={{float:'none',overflow: 'hidden'}}>
                <div>
                    <input type="submit" className="next-step" name="next step" value="x" title="Delete problem" onClick={
                    function() { if (!window.confirm("Delete problem?")) { return; }
                                 store.dispatch({ type : REMOVE_PROBLEM, PROBLEM_INDEX : problemIndex}) }}/>&nbsp;&nbsp;
                    Problem number <input type="text" value={this.props.value[PROBLEM_NUMBER]} className="problem-number" onChange={
                    function(evt) { store.dispatch({ type : SET_PROBLEM_NUMBER, PROBLEM_INDEX : problemIndex, 
                                    NEW_PROBLEM_NUMBER : evt.target.value}) }}/> &nbsp;&nbsp;&nbsp;
                    <input type="submit" className="next-step" name="next step" value="Clone Problem" 
                                    title="Make a copy of this work, useful if you need to refernce it while trying another solution path." onClick={
                    function() { store.dispatch({ type : CLONE_PROBLEM, PROBLEM_INDEX : problemIndex}) }}/>
                </div>
                <div style={{float:'left'}}>
                    <p> Actions </p>
                    <input type="submit" className="next-step" name="next step" value="next step (enter)" onClick={
                        function() { store.dispatch({ type : NEW_STEP, PROBLEM_INDEX : problemIndex}) }}/> <br/>
                    <input type="submit" className="undo-step" name="undo step" value="undo step (ctrl-z)" onClick={
                        function() { store.dispatch({ type : UNDO_STEP, PROBLEM_INDEX : problemIndex}) }}/> <br/>
                    <input type="submit" className="redo-step" name="redo step" value="redo step (ctrl-shift-z)" onClick={
                        function() { store.dispatch({ type : REDO_STEP, PROBLEM_INDEX : problemIndex}) }}/>
                </div>
                    <div style={{float:'left'}} className="equation-list">
                    <p> Type math here </p>
                    {
                        this.props.value[STEPS].map(function(step, stepIndex) {
                        if (stepIndex > lastShownStep) return;
                        return (
                        <MathInput key={stepIndex} stepIndex={stepIndex} problemIndex={problemIndex} value={step}/>
                        );
                    })}
                </div>
            </div>
        );
    }
});

var Assignment = React.createClass({
    render: function() {
      console.log('rendering...'); 
      console.log(this.props.value);
      var defaultEqtn = "4-9\\left(\\frac{2}{3}\\right)^2+\\frac{4}{5-3\\cdot 4}";
      return (
        <div id="assignment-container">
        <p>Open Notebook allows you to complete your math homework on your computer. The first problem has been created for you,
           use the box below to write an equation. When you want to modify it to solve your math problem click
           the "next step" button to copy your expression or equation and edit it on the next line to show your work.
           This tool is designed to take care of some of the busywork of math, which makes it easier to record all
           of your thinking without a bunch of manual copying.</p>

        <p> For example, try typing to following expression and simplifying it, even if you can do
        parts of it in your head, use the tool to make sure you show your work. 
        <span className="mathquill-static-math" ref="exampleStaticMath">{defaultEqtn}</span></p>

        Assignment Name <input type="text" id="assignment-name-text" name="assignment name" value={this.props.value[ASSIGNMENT_NAME]}/>
        <input type="submit" id="save-assignment" name="save assignment" value="save assignment" onClick={
                        function() { saveAssignment() }} /> <br/>
        {this.props.value[PROBLEMS].map(function(problem, problemIndex) {
            return (
              <Problem value={problem} key={problemIndex} id={problemIndex}/>
            );
        })}
        <button onClick={function() { store.dispatch({ type : ADD_PROBLEM}); }}>Add Problem</button>
        </div>
      )
    },

    componentDidMount: function() {
        MathQuill.StaticMath(ReactDOM.findDOMNode(this.refs.exampleStaticMath));
    }
    ,
});

var TeacherInteractiveGrader = React.createClass({
    render: function() {
        return (
            <TeacherGraderFilters value={this.props.value}/>
        );
    }
});


var TeacherGraderFilters = React.createClass({
    render: function() {
        return (
        <div className="assignment-filters">
            <div style={{width:"100%", overflow:"hidden"}}>
                <div style={{float:"left"}}>Show Student Work that is:</div>
                <div className="show-incorrect-div"><label><input type="checkbox" id="show-incorrect" checked="checked"/>incorrect</label></div>
                {
                    // this is unchecked programmatically to hide all of the correct work by default
                    // there was a weird bug where parens weren't showing up with other attempts to hide
                    // it programatically
                }
                <div className="show-partially-correct-div">
                    <label><input type="checkbox" id="show-partially-correct" checked="checked"/>partially correct</label></div>
                <div className="show-correct-div">
                    <label><input type="checkbox" id="show-correct" checked="checked"/>correct</label></div>
            </div>
            <div><label>&nbsp;<input type="checkbox" id="show-student-names" checked="checked"/>Show student names (or grade anonymously)</label></div>
        </div>
        );
    }
});

// Copied from Khan's Perseus project
let pendingScripts = [];
let pendingCallbacks = [];
let needsProcess = false;

const process = (script, callback) => {
    pendingScripts.push(script);
    pendingCallbacks.push(callback);
    if (!needsProcess) {
        needsProcess = true;
        setTimeout(doProcess, 0);
    }
};

const loadMathJax = (callback) => {
    if (typeof MathJax !== "undefined") {
        callback();
    } else if (typeof Khan !== "undefined" && Khan.mathJaxLoaded) {
        Khan.mathJaxLoaded.then(callback);
    } else {
        throw new Error(
            "MathJax wasn't loaded before it was needed by <TeX/>");
    }
};

const doProcess = () => {
    loadMathJax(() => {
        MathJax.Hub.Queue(function() {
            const oldElementScripts = MathJax.Hub.elementScripts;
            MathJax.Hub.elementScripts = (element) => pendingScripts;

            try {
                return MathJax.Hub.Process(null, () => {
                    // Trigger all of the pending callbacks before clearing them
                    // out.
                    for (const callback of pendingCallbacks) {
                        callback();
                    }

                    pendingScripts = [];
                    pendingCallbacks = [];
                    needsProcess = false;
                });
            } catch (e) {
                // IE8 requires `catch` in order to use `finally`
                throw e;
            } finally {
                MathJax.Hub.elementScripts = oldElementScripts;
            }
        });
    });
};

// Make content only visible to screen readers.
// Both collegeboard.org and Bootstrap 3 use this exact implementation.
const srOnly = {
    border: 0,
    clip: "rect(0,0,0,0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    width: "1px",
};

const TeX = React.createClass({
    propTypes: {
        children: React.PropTypes.node,
        onClick: React.PropTypes.func,
        onRender: React.PropTypes.func,
        style: React.PropTypes.any,
    },

    mixins: [PureRenderMixin],

    getDefaultProps: function() {
        return {
            // Called after math is rendered or re-rendered
            onRender: function() {},
            onClick: null,
        };
    },

    componentDidMount: function() {
        this._root = ReactDOM.findDOMNode(this);

        if (this.refs.katex.childElementCount > 0) {
            // If we already rendered katex in the render function, we don't
            // need to render anything here.
            this.props.onRender(this._root);
            return;
        }

        const text = this.props.children;

        this.setScriptText(text);
        process(this.script, () => this.props.onRender(this._root));
    },

    componentDidUpdate: function(prevProps, prevState) {
        // If we already rendered katex in the render function, we don't
        // need to render anything here.
        if (this.refs.katex.childElementCount > 0) {
            if (this.script) {
                // If we successfully rendered KaTeX, check if there's
                // lingering MathJax from the last render, and if so remove it.
                loadMathJax(() => {
                    const jax = MathJax.Hub.getJaxFor(this.script);
                    if (jax) {
                        jax.Remove();
                    }
                });
            }

            this.props.onRender();
            return;
        }

        const newText = this.props.children;

        if (this.script) {
            loadMathJax(() => {
                MathJax.Hub.Queue(() => {
                    const jax = MathJax.Hub.getJaxFor(this.script);
                    if (jax) {
                        return jax.Text(newText, this.props.onRender);
                    } else {
                        this.setScriptText(newText);
                        process(this.script, this.props.onRender);
                    }
                });
            });
        } else {
            this.setScriptText(newText);
            process(this.script, this.props.onRender);
        }
    },

    componentWillUnmount: function() {
        if (this.script) {
            loadMathJax(() => {
                const jax = MathJax.Hub.getJaxFor(this.script);
                if (jax) {
                    jax.Remove();
                }
            });
        }
    },

    setScriptText: function(text) {
        if (!this.script) {
            this.script = document.createElement("script");
            this.script.type = "math/tex";
            ReactDOM.findDOMNode(this.refs.mathjax).appendChild(this.script);
        }
        if ("text" in this.script) {
            // IE8, etc
            this.script.text = text;
        } else {
            this.script.textContent = text;
        }
    },

    render: function() {
        let katexHtml = null;
        try {
            katexHtml = {
                __html: katex.renderToString(this.props.children),
            };
        } catch (e) {
            /* jshint -W103 */
            if (e.__proto__ !== katex.ParseError.prototype) {
            /* jshint +W103 */
                throw e;
            }
        }

        let katexA11yHtml = null;
        if (katexHtml) {
            try {
                katexA11yHtml = {
                    __html: katexA11y.renderString(this.props.children),
                };
            } catch (e) {
                // Nothing
            }
        }

        return <span
            style={this.props.style}
            onClick={this.props.onClick}
        >
            <span ref="mathjax" />
            <span
                ref="katex"
                dangerouslySetInnerHTML={katexHtml}
                aria-hidden={!!katexHtml && !!katexA11yHtml}
            />
            <span
                dangerouslySetInnerHTML={katexA11yHtml}
                style={srOnly}
            />
        </span>;
    },
});

// End static math render copied from Perseus


var GraderForSingleSolution = React.createClass({
    render: function() {
        return (
        {/*
        '<div class="student-work ' + 'answer-' + studentWork.autoGradeStatus + " student-filename-" + studentWork.studentFile + '" style="float:left"> <!-- container for nav an equation list -->' +
            '<div style="float:left" class="equation-list"></div>' + 
        '</div>';
        */}
    );
    }
});

var OpenNotebook = React.createClass({
  render: function() {
    // TODO - figure out how to best switch between teacher and
    // student mode rendering
    if (this.props.value[APP_MODE] === EDIT_ASSIGNMENT) {
      return (
        <Assignment value={this.props.value}/>
      );
    } else if (this.props.value[APP_MODE] === GRADE_ASSIGNMENTS) {
        return (
            <TeacherInteractiveGrader value={this.props.value}/>
        );
    }
  }
});

store.subscribe(render);
$(function() {
    render();
    $('#open-file-input').change(readSingleFile);
    $('#open-student-submissions-input').change(studentSubmissionsZip);
});

// in the teacher grading experince, student work is grouped by similar final answer
// these groups are called solution classes
function testGradeSolutionClass() {

    var input = {
        CURRENT_FILTERS : { SIMILAR_ASSIGNMENT_GROUP_INDEX : null, CORRECTNESS : [ CORRECT, PARTIALLY_CORRECT, INCORRECT], ANONYMOUS : true },
        SIMILAR_ASSIGNMENT_SETS : [ ],
        STUDENT_WORK : { "1" : {
            POSSIBLE_POINTS : 6,
            UNIQUE_ANSWERS : [ 
            { ANSWER : "x=2", FILTER : SHOW_ALL, STUDENT_WORK : [ 
                { STUDENT_FILE : "jake r.", AUTOMATICALLY_ASSIGNED_SCORE : 0, 
                  SCORE : 0, FEEDBACK : "",
                  STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=2"} ] },
                { STUDENT_FILE : "alica m.", AUTOMATICALLY_ASSIGNED_SCORE : 0,
                  SCORE : 0, FEEDBACK : "",
                  STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "5x=10"},{ CONTENT : "x=2"} ] }] }, 
            { ANSWER : "x=-2", FILTER : SHOW_ALL, STUDENT_WORK : [
                { STUDENT_FILE : "jon m.", AUTOMATICALLY_ASSIGNED_SCORE : 0,
                  SCORE : 0, FEEDBACK : "",
                  STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=-2"} ] } ] } ]
        } }
    };
    var expectedOutput = {
        CURRENT_FILTERS : { SIMILAR_ASSIGNMENT_GROUP_INDEX : null, CORRECTNESS : [ CORRECT, PARTIALLY_CORRECT, INCORRECT], ANONYMOUS : true },
        SIMILAR_ASSIGNMENT_SETS : [ ],
        STUDENT_WORK : { "1" : {
            POSSIBLE_POINTS : 6,
            UNIQUE_ANSWERS : [ 
                { ANSWER : "x=2", FILTER : SHOW_ALL, STUDENT_WORK : [ 
                    {STUDENT_FILE : "jake r.", AUTOMATICALLY_ASSIGNED_SCORE : 0, SCORE : 3, FEEDBACK : "", STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=2"} ] },
                    {STUDENT_FILE : "alica m.", AUTOMATICALLY_ASSIGNED_SCORE : 0, SCORE : 3, FEEDBACK : "", STEPS : [ 
                        { CONTENT : "5x=10"},{ CONTENT : "5x=10"},{ CONTENT : "x=2"} 
                        ] } 
                ] }, 
                { ANSWER : "x=-2", FILTER : SHOW_ALL, STUDENT_WORK : [ {STUDENT_FILE : "jon m.", AUTOMATICALLY_ASSIGNED_SCORE : 0, SCORE : 0, FEEDBACK : "",
                    STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=-2"} ] } ] } ]
        } }
    };
    deepFreeze(input);
    var output = grading(input, { type : GRADE_CLASS_OF_SOLUTIONS, PROBLEM_NUMBER : "1", SOLUTION_CLASS_INDEX : 0, SCORE : 3} );
    expect(output).toEqual(expectedOutput);
}


function testGradeSingleSolution() {
    var input = {
        CURRENT_FILTERS : { SIMILAR_ASSIGNMENT_GROUP_INDEX : null, CORRECTNESS : [ CORRECT, PARTIALLY_CORRECT, INCORRECT], ANONYMOUS : true },
        SIMILAR_ASSIGNMENT_SETS : [ ],
        STUDENT_WORK : { "1" : {
            POSSIBLE_POINTS : 6,
            UNIQUE_ANSWERS : [ 
            { ANSWER : "x=2", FILTER : SHOW_ALL, STUDENT_WORK : [ 
                { STUDENT_FILE : "jake r.", AUTOMATICALLY_ASSIGNED_SCORE : 0, 
                  SCORE : 0, FEEDBACK : "",
                  STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=2"} ] },
                { STUDENT_FILE : "alica m.", AUTOMATICALLY_ASSIGNED_SCORE : 0,
                  SCORE : 0, FEEDBACK : "",
                  STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "5x=10"},{ CONTENT : "x=2"} ] }] }, 
            { ANSWER : "x=-2", FILTER : SHOW_ALL, STUDENT_WORK : [
                { STUDENT_FILE : "jon m.", AUTOMATICALLY_ASSIGNED_SCORE : 0,
                  SCORE : 0, FEEDBACK : "",
                  STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=-2"} ] } ] } ]
        } }
    };
    var expectedOutput = {
        CURRENT_FILTERS : { SIMILAR_ASSIGNMENT_GROUP_INDEX : null, CORRECTNESS : [ CORRECT, PARTIALLY_CORRECT, INCORRECT], ANONYMOUS : true },
        SIMILAR_ASSIGNMENT_SETS : [ ],
        STUDENT_WORK : { "1" : {
            POSSIBLE_POINTS : 6,
            UNIQUE_ANSWERS : [ 
                { ANSWER : "x=2", FILTER : SHOW_ALL, STUDENT_WORK : [ 
                    {STUDENT_FILE : "jake r.", AUTOMATICALLY_ASSIGNED_SCORE : 0, SCORE : 3, FEEDBACK : "", STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=2"} ] },
                    {STUDENT_FILE : "alica m.", AUTOMATICALLY_ASSIGNED_SCORE : 0, SCORE : 0, FEEDBACK : "", STEPS : [ 
                        { CONTENT : "5x=10"},{ CONTENT : "5x=10"},{ CONTENT : "x=2"} 
                        ] } 
                ] }, 
                { ANSWER : "x=-2", FILTER : SHOW_ALL, STUDENT_WORK : [ {STUDENT_FILE : "jon m.", AUTOMATICALLY_ASSIGNED_SCORE : 0, SCORE : 0, FEEDBACK : "",
                    STEPS : [ { CONTENT : "5x=10"},{ CONTENT : "x=-2"} ] } ] } ]
        } }
    };
    deepFreeze(input);
    var output = grading(input, { type : GRADE_SINGLE_SOLUTION, PROBLEM_NUMBER : "1", SOLUTION_CLASS_INDEX : 0, SCORE : 3, SOLUTION_INDEX : 0} );
    console.log(output);
    console.log(expectedOutput);
    expect(output).toEqual(expectedOutput);
}



function testAddProblem() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 0 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 0 }
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 0 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 0 },
                     { PROBLEM_NUMBER : "", STEPS : [""], LAST_SHOWN_STEP : 0 }
        ]
        
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : ADD_PROBLEM })
    ).toEqual(expectedAssignment);
}

function testRemoveProblem() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1},
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1}
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1} ]
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : REMOVE_PROBLEM, PROBLEM_INDEX : 1 })
    ).toEqual(expectedAssignment);
    }

function testCloneProblem() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1},
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1}
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1},
                     { PROBLEM_NUMBER : "1 - copy", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1},
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1}
        ]
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : CLONE_PROBLEM, PROBLEM_INDEX : 0 })
    ).toEqual(expectedAssignment);
}

function testRenameProblem() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1},
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1}
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 },
                     { PROBLEM_NUMBER : "1.a", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1 }
        ]
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : SET_PROBLEM_NUMBER, PROBLEM_INDEX : 1, NEW_PROBLEM_NUMBER : "1.a"})
    ).toEqual(expectedAssignment);
}

function testEditStep() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1 }
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "5"], LAST_SHOWN_STEP : 1 }
        ]
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : EDIT_STEP, PROBLEM_INDEX : 1, STEP_KEY : 1, NEW_STEP_CONTENT : "5"})
    ).toEqual(expectedAssignment);
}

function testNewStep() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1 }
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2", "2"], LAST_SHOWN_STEP : 2 }
        ]
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : NEW_STEP, PROBLEM_INDEX : 1})
    ).toEqual(expectedAssignment);
}

function testUndoStep() {
    var initialProblem = { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 };
    var expectedProblem = { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 0 };
    deepFreeze(initialProblem);
    expect(
        problem(initialProblem, { type : UNDO_STEP})
    ).toEqual(expectedProblem);
}

function testRedoStep() {
    var initialProblem = { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 0 };
    var expectedProblem = { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 };
    deepFreeze(initialProblem);
    expect(
        problem(initialProblem, { type : REDO_STEP})
    ).toEqual(expectedProblem);
}

// Run tests
// TODO - seperate these from app code
testAddProblem();
testRemoveProblem();
testCloneProblem();
testRenameProblem();
testEditStep();
testNewStep();
testUndoStep();
testRedoStep();
testGradeProblem();
testAggregateStudentWork();
testAggregateStudentWorkNoAnswerKey();
testGradeSolutionClass();
testGradeSingleSolution();
// test utility method
testNestedUpdate();
console.log("All tests complete");

</script>
</head>
<body>
<!-- this is not currently rendered by React, not sure how to make that work as it will be inside of the root div-->
<div class="menuBar">
    <!-- img class="logo" src="logo.jpg"/ -->
    <div class="nav"> 
        <b>Open Notebook</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Open Assignment <input type="file" id="open-file-input"/> 
        Grade Student Assignments <input type="file" id="open-student-submissions-input" />
    </div>
</div>
<div id="root"></div>
</body>
</html>
