<!DOCTYPE html>
<!--    
    This file is part of OpenNotebook-Web

    OpenNotebook-Web is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenNotebook-Web is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenNotebook-Web.  If not, see <http://www.gnu.org/licenses/>. 
-->
<html>
<head>
<!-- http://paletton.com/#uid=13u0u0kllllaFw0g0qFqFg0w0aF --> 

<meta name="viewport" content="width=624">
<title>Open Notebook</title>

<link rel="stylesheet" type="text/css" href="../build/mathquill.css">
<link rel="stylesheet" type="text/css" href="support/home.css">
<!-- testing -->
<script src="../expect.min.js"></script>

<!-- UI react-->
<script src="react/build/react.js"></script>
<script src="react/build/react-dom.js"></script>

<script src="../babel.min.js"></script>
<!-- input sanitiation --> 
<!-- script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.2/marked.min.js"></script -->

<!-- saving to local disk -->
<script type="text/javascript" src="../filesaver_js.js"></script>

<!-- Only use this for MathQuill! --> 
<script type="text/javascript" src="support/jquery-1.7.2.js"></script>

<script type="text/javascript" src="../build/mathquill-basic.js"></script>
<!-- App state management -->
<script type="text/javascript" src="../redux.js"></script>
<script type="text/javascript" src="../lodash.min.js"></script>
<script type="text/babel">

// copied from here, didn't seem worth adding a dependency, I'm sure the JS people will cure me of that eventually...
// https://github.com/substack/deep-freeze/blob/master/index.js
function deepFreeze (o) {
  Object.freeze(o);

  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (o.hasOwnProperty(prop)
    && o[prop] !== null
    && (typeof o[prop] === "object" || typeof o[prop] === "function")
    && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  
  return o;
};

//Learning Redux

const UNTITLED_ASSINGMENT = 'Untitled Assignment';

// Application state properties
// TODO - use these as the actual keys in object literals in the reducer
// when I have ES6 and Babel

// Redux things
var type = 'type';

// Application modes
var APP_MODE = 'APP_MODE';
var EDIT_ASSIGNMENT = 'EDIT_ASSIGNMENT';
var GRADE_ASSIGNMENTS = 'GRADE_ASSIGNMENTS';

// Assignment properties
var ASSIGNMENT_NAME = 'ASSIGNMENT_NAME';
var PROBLEMS = 'PROBLEMS';

// Problem properties
var PROBLEM_NUMBER = 'PROBLEM_NUMBER';
var STEPS = 'STEPS';
// to implement undo/redo and index for the last step
// to show is tracked and moved up and down
// when this is not at the end of the list and a new
// step is added it moves to the end of the list as
// the redo history in this case will be lost
var LAST_SHOWN_STEP = 'LAST_SHOWN_STEP';

// editing assignmnt mode actions
var SET_ASSIGNMENT_NAME = 'SET_ASSIGNMENT_NAME';
// used to swap out the entire content of the document, for opening
// a document from a file
var SET_ASSIGNMENT_CONTENT = 'SET_ASSIGNMENT_CONTENT';

// actions
var ADD_PROBLEM = 'ADD_PROBLEM';
// remove problem expects an "index" property 
// specifying which problem to remove
var REMOVE_PROBLEM = 'REMOVE_PROBLEM';
var CLONE_PROBLEM = 'CLONE_PROBLEM';

// this action expects:
// PROBLEM_INDEX - for which problem to change
// NEW_PROBLEM_NUMBER - string with problem number, not a numberic
//                    type because the problem might be 1.a, etc.
var PROBLEM_INDEX = 'PROBLEM_INDEX';
var NEW_PROBLEM_NUMBER = 'NEW_PROBLEM_NUMBER';
var SET_PROBLEM_NUMBER = 'SET_PROBLEM_NUMBER';

// key used to refer to one step in a series of student work
var STEP_KEY = 'STEP_KEY';
// key used to refer to data to place at a given step
// currently will just be a string with latex, but may change
// type if other metadata needs to be stored with each step
// such as a flag the student could set to indicate more than
// 1 final answer
var NEW_STEP_CONTENT = 'NEW_STEP_CONTENT';

// this action expects:
// PROBLEM_INDEX - for which problem to change
// STEP_KEY - index into the work steps for the given problem
// NEW_STEP_CONTENT - string for the new expression to write in this step
var EDIT_STEP = 'EDIT_STEP';
// TODO - decide if I want to add a feature to splice in
// a new step partway through a current problem
// this action expects an index for which problem to change
var NEW_STEP = 'NEW_STEP';
// this action expects an index for which problem to change
var UNDO_STEP = 'UNDO_STEP';
// this action expects an index for which problem to change
var REDO_STEP = 'REDO_STEP';

function saveAssignment() {
    var blob = new Blob([JSON.stringify({ PROBLEMS : store.getState()[PROBLEMS]})], {type: "text/plain;charset=utf-8"});
    saveAs(blob, store.getState()[ASSIGNMENT_NAME] + '.math'); 
}

// read a file from the local disk, pass an onChange event from a "file" input type
// http://www.htmlgoodies.com/beyond/javascript/read-text-files-using-the-javascript-filereader.html
function readSingleFile(evt) {
    //Retrieve the first (and only!) File from the FileList object
    var f = evt.target.files[0]; 

    if (f) {
        var r = new FileReader();
        r.onload = function(e) { 
            var contents = e.target.result;
            openAssignment(contents, f.name);  
        }
        r.readAsText(f);
    } else { 
        alert("Failed to load file");
    }
}

function openAssignment(serializedDoc, filename) {
    if (!window.confirm("Discard your current work and open the selected document?")) { 
        return; 
    }
    var newDoc = JSON.parse(serializedDoc);
    // compatibility for old files, need to convert the old proerty names as
    // well as add the LAST_SHOWN_STEP
    var newDoc = convertToCurrentFormat(newDoc);
    store.dispatch({type : SET_ASSIGNMENT_CONTENT, PROBLEMS : newDoc[PROBLEMS]});
    store.dispatch({type : SET_ASSIGNMENT_NAME, ASSIGNMENT_NAME : removeExtension(filename)});
}

function removeExtension(filename) {
    // remove preceding directory (for when filename comes out of the ZIP directory)
    filename = filename.replace(/[^\/]*\//, "");
    // actually remove extension
    filename = filename.replace(/\.[^/.]+$/, "");
    return filename;
}

function convertToCurrentFormat(possiblyOldDoc) {
    console.log(possiblyOldDoc);
    if (!possiblyOldDoc.hasOwnProperty('problems')) {
        console.log('new doc found');
        return possiblyOldDoc;
    }

    possiblyOldDoc.problems.forEach(function (problem) {
        if (problem.problemNumber !== undefined) {
            var newSteps = problem.steps;
            problem[STEPS] = newSteps;
            problem[LAST_SHOWN_STEP] = newSteps.length - 1;
            problem[PROBLEM_NUMBER] = problem.problemNumber;
            delete problem.steps;
            delete problem.problemNumber;
        }
    });
    possiblyOldDoc[PROBLEMS] = possiblyOldDoc.problems;
    return possiblyOldDoc;
}

// reducer for an individual problem
function problem(problem, action) {
    if (problem === undefined) {
        return { PROBLEM_NUMBER : "", STEPS : [""], LAST_SHOWN_STEP : 0}
    } else if (action.type === SET_PROBLEM_NUMBER) {
        var newNamedProb = _.clone(problem)
        newNamedProb[PROBLEM_NUMBER] = action[NEW_PROBLEM_NUMBER];
        return newNamedProb;
    } else if (action.type === EDIT_STEP) {
        // TODO - I should avoid using cloneDeep, I think it migh be okay here though
        var editedProb = _.cloneDeep(problem)
        editedProb.STEPS[action.STEP_KEY] = action.NEW_STEP_CONTENT;
        return editedProb;
    } else if (action.type === NEW_STEP) {
        var editedProb = _.cloneDeep(problem);
        var oldLastStep = editedProb.STEPS[problem.LAST_SHOWN_STEP];
        editedProb[STEPS] = editedProb[STEPS].slice(0, problem.LAST_SHOWN_STEP + 1);
        editedProb[STEPS].push(oldLastStep);
        editedProb[LAST_SHOWN_STEP]++;
        return editedProb;
    } else if (action.type === UNDO_STEP) {
        if (problem[LAST_SHOWN_STEP] == 0) return problem;
        else {
            var editedProb = _.cloneDeep(problem);
            editedProb[LAST_SHOWN_STEP]--;
            return editedProb;
        }
    } else if (action.type === REDO_STEP) {
        if (problem[LAST_SHOWN_STEP] == problem[STEPS].length - 1) return problem;
        else {
            var editedProb = _.cloneDeep(problem);
            editedProb[LAST_SHOWN_STEP]++;
            return editedProb;
        }
    } else {
        return problem;
    }
}

// reducer for the list of problems in an assignment
function problems(probList, action) {
    if (probList === undefined) {
        return [ problem(undefined, action) ];
    }

    if (action.type === ADD_PROBLEM) {
        return _.clone(probList).concat(problem(undefined, action));
    } else if (action.type === REMOVE_PROBLEM) {
        return [
            ...probList.slice(0, action.PROBLEM_INDEX),
            ...probList.slice(action.PROBLEM_INDEX + 1)
        ];
    } else if (action.type === CLONE_PROBLEM) {
        var newProb = _.cloneDeep(probList[action.PROBLEM_INDEX]);
        newProb[PROBLEM_NUMBER] += ' - copy'; 
        return [
            ...probList.slice(0, action.PROBLEM_INDEX + 1),
            newProb,
            ...probList.slice(action.PROBLEM_INDEX + 1)
        ];
    } else if (action.type === SET_PROBLEM_NUMBER ||
               action.type === EDIT_STEP ||
               action.type === UNDO_STEP ||
               action.type === REDO_STEP ||
               action.type === NEW_STEP) {
        return [ 
            ...probList.slice(0, action.PROBLEM_INDEX),
            problem(probList[action.PROBLEM_INDEX], action),
            ...probList.slice(action.PROBLEM_INDEX + 1)
        ];
        return ret;
    } else {
        return probList;
    }
}

// reducer for an overall assignment
function assignment(state, action) {
    console.log(action);
    if (state === undefined) {
        return {
            APP_MODE : EDIT_ASSIGNMENT,
            ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
            PROBLEMS : problems(undefined, action)
        };
    } else if (action.type === SET_ASSIGNMENT_NAME) {
        state = _.cloneDeep(state);
        state.ASSIGNMENT_NAME = action.ASSIGNMENT_NAME;
        return state;
    } else if (action.type === SET_ASSIGNMENT_CONTENT) {
        state = _.cloneDeep(state);
        state.PROBLEMS = action.PROBLEMS;
        console.log('new state');
        console.log(state);
        return state;
    } else {
        var new_state = _.clone(state);
        new_state[PROBLEMS] = problems(new_state[PROBLEMS], action); 
        return new_state;
    }
}

var createStore = Redux.createStore;
var store = createStore(assignment);

function render() {
    ReactDOM.render(
        <OpenNotebook value={store.getState()} />,
        document.getElementById('root')
    );
}

MathQuill.interfaceVersion(1);
var PT = React.PropTypes;

// A WYSIWYG math input that calls `onChange(LaTeX-string)`
var MathInput = React.createClass({
    propTypes: {
        value: PT.string,
        convertDotToTimes: PT.bool,
        buttonsVisible: PT.oneOf(['always', 'never', 'focused']),
        labelText: React.PropTypes.string,
        onFocus: PT.func,
        onBlur: PT.func,
    },

    render: function() {
        // mathquill usually adds these itself but react removes them when
        // updating the component.
        var className = "perseus-math-input mq-editable-field mq-math-mode";

        if (this.props.className) {
            className = className + " " + this.props.className;
        }

        var buttons = null;
        /*
        if (this._shouldShowButtons()) {
            buttons = <TexButtons
                sets={this.props.buttonSets}
                className="math-input-buttons absolute"
                convertDotToTimes={this.props.convertDotToTimes}
                onInsert={this.insert} />;
        }
        */

        return <div>
            <div style={{display: 'inline-block'}}>
                <span className={className}
                      ref="mathinput"
                      aria-label={this.props.labelText}
                      onFocus={this.handleFocus}
                      onBlur={this.handleBlur} />
            </div>
        </div>;
    },

    // handlers:
    // keep track of two related bits of state:
    // * this.state.focused - whether the buttons are currently shown
    // * this.mouseDown - whether a mouse click is active that started in the
    //   buttons div

    handleFocus: function() {
        console.log("focused");
        this.setState({ focused: true });
        // TODO(joel) fix properly - we should probably allow onFocus handlers
        // to this property, but we need to work correctly with them.
        // if (this.props.onFocus) {
        //     this.props.onFocus();
        // }
    },

    handleMouseDown: function(event) {
        var focused = ReactDOM.findDOMNode(this).contains(event.target);
        this.mouseDown = focused;
        if (!focused) {
            this.setState({ focused: false });
        }
    },

    handleMouseUp: function() {
        // this mouse click started in the buttons div so we should focus the
        // input
        if (this.mouseDown) {
            this.focus();
        }
        this.mouseDown = false;
    },

    handleBlur: function() {
        if (!this.mouseDown) {
            this.setState({ focused: false });
        }
    },

    _shouldShowButtons: function() {
        if (this.props.buttonsVisible === 'always') {
            return true;
        } else if (this.props.buttonsVisible === 'never') {
            return false;
        } else {
            return this.state.focused;
        }
    },

    getDefaultProps: function() {
        return {
            value: "",
            convertDotToTimes: false,
            buttonsVisible: 'focused'
        };
    },

    getInitialState: function() {
        return { focused: false };
    },

    insert: function(value) {
        var input = this.mathField();
        if (_(value).isFunction()) {
            value(input);
        } else if (value[0] === '\\') {
            input.cmd(value).focus();
        } else {
            input.write(value).focus();
        }
        input.focus();
    },

    mathField: function(options) {
        // MathQuill.MathField takes a DOM node, MathQuill-ifies it if it's
        // seeing that node for the first time, then returns the associated
        // MathQuill object for that node. It is stable - will always return
        // the same object when called on the same DOM node.
        return MathQuill.MathField(ReactDOM.findDOMNode(this.refs.mathinput), options);
    },

    componentWillUnmount: function() {
        window.removeEventListener("mousedown", this.handleMouseDown);
        window.removeEventListener("mouseup", this.handleMouseUp);
    },

    componentDidMount: function() {
        window.addEventListener("mousedown", this.handleMouseDown);
        window.addEventListener("mouseup", this.handleMouseUp);

        // These options can currently only be set globally. (Hopefully this
        // will change at some point.) They appear safe to set multiple times.

        // LaTeX commands that, when typed, are immediately replaced by the
        // appropriate symbol. This does not include ln, log, or any of the
        // trig functions; those are always interpreted as commands.
        //MathQuill.addAutoCommands("pi theta phi sqrt nthroot");

        // Pop the cursor out of super/subscripts on arithmetic operators or
        // (in)equalities.
        // MathQuill.addCharsThatBreakOutOfSupSub("+-*/=<>≠≤≥");

        // Prevent excessive super/subscripts or fractions from being created
        // without operands, e.g. when somebody holds down a key
        //MathQuill.disableCharsWithoutOperand("^_/");

        var initialized = false;
        console.log(this)

        // Initialize MathQuill.MathField instance
        this.mathField({
            // The name of this option is somewhat misleading, as tabbing in
            // MathQuill breaks you out of a nested context (fraction/script)
            // if you're in one, but moves focus to the next input if you're
            // not. Spaces (with this option enabled) are just ignored in the
            // latter case.
            //
            // TODO(alex): In order to allow inputting mixed numbers, we will
            // have to accept spaces in certain cases. The desired behavior is
            // still to escape nested contexts if currently in one, but to
            // insert a space if not (we don't expect mixed numbers in nested
            // contexts). We should also limit to one consecutive space.
            spaceBehavesLikeTab: true,

            // for intuitive navigation of fractions
            leftRightIntoCmdGoes: 'up',
            autoCommands: 'pi theta sqrt sum',
            autoSubscriptNumerals: true,
            charsThatBreakOutOfSupSub: '+-*/=<>≠≤≥',

            handlers: {
                edited: (mathField) => {
                    // This handler is guaranteed to be called on change, but
                    // unlike React it sometimes generates false positives.
                    // One of these is on initialization (with an empty string
                    // value), so we have to guard against that below.
                    console.log("EDITED!");
                    var value = mathField.latex();

                    // Provide a MathQuill-compatible way to generate the
                    // not-equals sign without pasting unicode or typing TeX
                    value = value.replace(/<>/g, "\\ne");

                    // Use the specified symbol to represent multiplication
                    // TODO(alex): Add an option to disallow variables, in
                    // which case 'x' should get converted to '\\times'
                    if (this.props.convertDotToTimes) {
                        value = value.replace(/\\cdot/g, "\\times");

                        // Preserve cursor position in the common case:
                        // typing '*' to insert a multiplication sign.
                        // We do this by modifying internal MathQuill state
                        // directly, instead of waiting for `.latex()` to be
                        // called in `componentDidUpdate()`.
                        var left = mathField.controller.cursor[MathQuill.L];
                        if (left && left.ctrlSeq === '\\cdot ') {
                            mathField.controller.backspace();
                            mathField.cmd('\\times');
                        }
                    } else {
                        value = value.replace(/\\times/g, "\\cdot");
                    }

                    if (initialized && this.props.value !== value) {
                        //this.props.onChange(value);
                        console.log("SETTING NEW VALUE");
                        store.dispatch({ type : EDIT_STEP, PROBLEM_INDEX : this.props.problemIndex, 
                                         STEP_KEY : this.props.stepIndex, NEW_STEP_CONTENT : value});
                    }
                },
                enter: () => {
                    // This handler is called when the user presses the enter
                    // key. Since this isn't an actual <input> element, we have
                    // to manually trigger the usually automatic form submit.

                    console.log("enter pressed");
                    // Using enter for go to next step
                    store.dispatch({ type : NEW_STEP, PROBLEM_INDEX : this.props.problemIndex});

                    //$(ReactDOM.findDOMNode(this.refs.mathinput)).submit();
                },
                upOutOf: (mathField) => {
                    // This handler is called when the user presses the up
                    // arrow key, but there is nowhere in the expression to go
                    // up to (no numerator or exponent). For ease of use,
                    // interpret this as an attempt to create an exponent.
                    console.log("Up");
                    mathField.typedText("^");
                }
            }
        });

        // Ideally, we would be able to pass an initial value directly into
        // the constructor above
        this.mathField().latex(this.props.value);
        this.mathField().focus();
        console.log("mathfield init");
        initialized = true;
    },

    componentDidUpdate: function() {
        console.log("mathfield component did update");
        if (!_.isEqual(this.mathField().latex(), this.props.value)) {
            console.log("mathfield component did update 2: " + this.props.value);
            console.log(this.props);
            this.mathField().latex(this.props.value);
        }
    },

    focus: function() {
        this.mathField().focus();
        this.setState({ focused: true });
    },

    blur: function() {
        this.mathField().blur();
        this.setState({ focused: false });
    }
});


var Problem = React.createClass({

    handleStepChange: function(event) {
      this.setState({value: event.target.value});
    },
    render: function() {
        var problemIndex = this.props.id;
        var lastShownStep = this.props.value[LAST_SHOWN_STEP];
        return (
            <div className="problem-container" style={{float:'none',overflow: 'hidden'}}>
                <div>
                    <input type="submit" className="next-step" name="next step" value="x" title="Delete problem" onClick={
                    function() { if (!window.confirm("Delete problem?")) { return; }
                                 store.dispatch({ type : REMOVE_PROBLEM, PROBLEM_INDEX : problemIndex}) }}/>&nbsp;&nbsp;
                    Problem number <input type="text" value={this.props.value[PROBLEM_NUMBER]} className="problem-number" onChange={
                    function(evt) { store.dispatch({ type : SET_PROBLEM_NUMBER, PROBLEM_INDEX : problemIndex, 
                                    NEW_PROBLEM_NUMBER : evt.target.value}) }}/> &nbsp;&nbsp;&nbsp;
                    <input type="submit" className="next-step" name="next step" value="Clone Problem" 
                                    title="Make a copy of this work, useful if you need to refernce it while trying another solution path." onClick={
                    function() { store.dispatch({ type : CLONE_PROBLEM, PROBLEM_INDEX : problemIndex}) }}/>
                </div>
                <div style={{float:'left'}}>
                    <p> Actions </p>
                    <input type="submit" className="next-step" name="next step" value="next step (enter)" onClick={
                        function() { store.dispatch({ type : NEW_STEP, PROBLEM_INDEX : problemIndex}) }}/> <br/>
                    <input type="submit" className="undo-step" name="undo step" value="undo step (ctrl-z)" onClick={
                        function() { store.dispatch({ type : UNDO_STEP, PROBLEM_INDEX : problemIndex}) }}/> <br/>
                    <input type="submit" className="redo-step" name="redo step" value="redo step (ctrl-shift-z)" onClick={
                        function() { store.dispatch({ type : REDO_STEP, PROBLEM_INDEX : problemIndex}) }}/>
                </div>
                    <div style={{float:'left'}} className="equation-list">
                    <p> Type math here </p>
                    {
                        this.props.value[STEPS].map(function(step, stepIndex) {
                        if (stepIndex > lastShownStep) return;
                        return (
                        <MathInput key={stepIndex} stepIndex={stepIndex} problemIndex={problemIndex} value={step}/>
                        );
                    })}
                </div>
            </div>
        );
    }
});

var Assignment = React.createClass({
    render: function() {
      console.log('rendering...'); 
      console.log(this.props.value);
      var defaultEqtn = "4-9\\left(\\frac{2}{3}\\right)^2+\\frac{4}{5-3\\cdot 4}";
      return (
        <div id="assignment-container">
        <p>Open Notebook allows you to complete your math homework on your computer. The first problem has been created for you,
           use the box below to write an equation. When you want to modify it to solve your math problem click
           the "next step" button to copy your expression or equation and edit it on the next line to show your work.
           This tool is designed to take care of some of the busywork of math, which makes it easier to record all
           of your thinking without a bunch of manual copying.</p>

        <p> For example, try typing to following expression and simplifying it, even if you can do
        parts of it in your head, use the tool to make sure you show your work. 
        <span className="mathquill-static-math" ref="exampleStaticMath">{defaultEqtn}</span></p>

        Assignment Name <input type="text" id="assignment-name-text" name="assignment name" value={this.props.value[ASSIGNMENT_NAME]}/>
        <input type="submit" id="save-assignment" name="save assignment" value="save assignment" onClick={
                        function() { saveAssignment() }} /> <br/>
        {this.props.value[PROBLEMS].map(function(problem, problemIndex) {
            return (
              <Problem value={problem} key={problemIndex} id={problemIndex}/>
            );
        })}
        <button onClick={function() { store.dispatch({ type : ADD_PROBLEM}); }}>Add Problem</button>
        </div>
      )
    },

    componentDidMount: function() {
        MathQuill.StaticMath(ReactDOM.findDOMNode(this.refs.exampleStaticMath));
    }
    ,
});

var OpenNotebook = React.createClass({
  render: function() {
    // TODO - figure out how to best switch between teacher and
    // student mode rendering
    if (this.props.value[APP_MODE] === EDIT_ASSIGNMENT) {
      return (
        <Assignment value={this.props.value}/>
      );
    }
  }
});

store.subscribe(render);
$(function() {
    render();
    $('#open-file-input').change(readSingleFile);
    //$('#open-student-submissions-input').change(studentSubmissionsZip);
});

function testAddProblem() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 0 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 0 }
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 0 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 0 },
                     { PROBLEM_NUMBER : "", STEPS : [""], LAST_SHOWN_STEP : 0 }
        ]
        
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : ADD_PROBLEM })
    ).toEqual(expectedAssignment);
}

function testRemoveProblem() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1},
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1}
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1} ]
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : REMOVE_PROBLEM, PROBLEM_INDEX : 1 })
    ).toEqual(expectedAssignment);
    }

function testCloneProblem() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1},
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1}
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1},
                     { PROBLEM_NUMBER : "1 - copy", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1},
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1}
        ]
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : CLONE_PROBLEM, PROBLEM_INDEX : 0 })
    ).toEqual(expectedAssignment);
}

function testRenameProblem() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1},
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1}
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 },
                     { PROBLEM_NUMBER : "1.a", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1 }
        ]
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : SET_PROBLEM_NUMBER, PROBLEM_INDEX : 1, NEW_PROBLEM_NUMBER : "1.a"})
    ).toEqual(expectedAssignment);
}

function testEditStep() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1 }
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "5"], LAST_SHOWN_STEP : 1 }
        ]
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : EDIT_STEP, PROBLEM_INDEX : 1, STEP_KEY : 1, NEW_STEP_CONTENT : "5"})
    ).toEqual(expectedAssignment);
}

function testNewStep() {
    var initialAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2"], LAST_SHOWN_STEP : 1 }
        ]
    }
    var expectedAssignment = {
        APP_MODE : EDIT_ASSIGNMENT,
        ASSIGNMENT_NAME : UNTITLED_ASSINGMENT,
        PROBLEMS : [ { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 },
                     { PROBLEM_NUMBER : "2", STEPS : ["4-2", "2", "2"], LAST_SHOWN_STEP : 2 }
        ]
    }
    deepFreeze(initialAssignment);
    expect(
        assignment(initialAssignment, { type : NEW_STEP, PROBLEM_INDEX : 1})
    ).toEqual(expectedAssignment);
}

function testUndoStep() {
    var initialProblem = { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 };
    var expectedProblem = { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 0 };
    deepFreeze(initialProblem);
    expect(
        problem(initialProblem, { type : UNDO_STEP})
    ).toEqual(expectedProblem);
}

function testRedoStep() {
    var initialProblem = { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 0 };
    var expectedProblem = { PROBLEM_NUMBER : "1", STEPS : ["1+2", "3"], LAST_SHOWN_STEP : 1 };
    deepFreeze(initialProblem);
    expect(
        problem(initialProblem, { type : REDO_STEP})
    ).toEqual(expectedProblem);
}

// Run tests
// TODO - seperate these from app code
testAddProblem();
testRemoveProblem();
testCloneProblem();
testRenameProblem();
testEditStep();
testNewStep();
testUndoStep();
testRedoStep();
console.log("All tests complete");

</script>
</head>
<body>
<!-- this is not currently rendered by React, not sure how to make that work as it will be inside of the root div-->
<div class="menuBar">
    <!-- img class="logo" src="logo.jpg"/ -->
    <div class="nav"> 
        <b>Open Notebook</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Open Assignment <input type="file" id="open-file-input"/> 
        Grade Student Assignments <input type="file" id="open-student-submissions-input" />
    </div>
</div>
<div id="root"></div>
</body>
</html>
